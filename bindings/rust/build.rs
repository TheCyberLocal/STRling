use std::env;
use std::fs;
use std::path::Path;
use glob::glob;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("conformance_generated.rs");
    
    let mut content = String::new();
    content.push_str("// This file is auto-generated by build.rs\n");
    content.push_str("use strling_core::core::nodes::Node;\n");
    content.push_str("use strling_core::core::ir::IROp;\n");
    content.push_str("use strling_core::core::compiler::Compiler;\n");
    content.push_str("use serde::Deserialize;\n");
    content.push_str("use std::fs;\n\n");
    
    content.push_str("#[derive(Deserialize)]\n");
    content.push_str("struct TestCase {\n");
    content.push_str("    id: String,\n");
    content.push_str("    input_ast: Option<Node>,\n");
    content.push_str("    expected_ir: Option<IROp>,\n");
    content.push_str("}\n\n");

    let pattern = "../../tests/spec/*.json";
    let paths = glob(pattern).expect("Failed to read glob pattern");

    for entry in paths {
        if let Ok(path) = entry {
            let file_stem = path.file_stem().unwrap().to_string_lossy();
            let file_name = path.file_name().unwrap().to_string_lossy();
            
            // Skip error tests
            if file_name.starts_with("error_") {
                continue;
            }

            // Sanitize function name
            let func_name = file_stem.replace("-", "_").replace(".", "_");
            // Use absolute path or relative to cargo manifest dir if possible, but here we use relative to workspace root which might be tricky if running from different dir.
            // Better to use CARGO_MANIFEST_DIR
            let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
            // We need to construct a path that works at runtime.
            // The path found by glob is relative to where build.rs runs (usually package root).
            // So `../../tests/spec` is correct relative to `bindings/rust`.
            // At runtime, tests run with CWD as package root too.
            let path_str = path.to_string_lossy().replace("\\", "/");

            content.push_str(&format!("#[test]\nfn test_{}() {{\n", func_name));
            content.push_str(&format!("    let path = \"{}\";\n", path_str));
            content.push_str("    let content = fs::read_to_string(path).expect(\"Failed to read file\");\n");
            content.push_str("    if content.contains(\"\\\"expected_error\\\"\") { return; }\n");
            content.push_str("    let test_case: TestCase = serde_json::from_str(&content).expect(\"Failed to deserialize\");\n");
            content.push_str("    if let (Some(ast), Some(expected)) = (test_case.input_ast, test_case.expected_ir) {\n");
            content.push_str("        let mut compiler = Compiler::new();\n");
            content.push_str("        let ir = compiler.compile(&ast);\n");
            content.push_str("        assert_eq!(ir, expected, \"Mismatch in test {}\", test_case.id);\n");
            content.push_str("    }\n");
            content.push_str("}\n\n");
        }
    }

    fs::write(&dest_path, content).unwrap();
    println!("cargo:rerun-if-changed=../../tests/spec");
}
