/**
 * @file Test Design â€” test_schema_validation.ts
 *
 * ## Purpose
 * This test suite verifies that the JSON artifacts produced by the STRling
 * compiler are structurally correct and conform to the official JSON Schema
 * definitions. It acts as a critical contract test, ensuring that the output of
 * the implementation adheres to the formal specification.
 *
 * ## Description
 * The STRling compiler's final output is a `TargetArtifact`, a JSON object whose
 * structure is formally defined by `base.schema.json` and its extensions (like
 * `pcre2.v1.schema.json`). This
 * test suite uses the `validator.py` utility to confirm that the artifacts
 * generated from various DSL patterns successfully validate against these schemas.
 * It tests both valid artifacts ("happy path") and deliberately malformed
 * artifacts to ensure the validation process itself is robust.
 *
 * ## Scope
 * -   **In scope:**
 * -   Validating artifacts generated by `parseToArtifact()` against
 * `base.schema.json`.
 * -   Validating artifacts that include PCRE2-specific fields against
 * `pcre2.v1.schema.json`.
 * -   Testing both valid and invalid artifact structures to confirm the
 * validator raises `jsonschema.ValidationError` when appropriate
 * .
 * -   **Out of scope:**
 * -   The semantic correctness of the artifact's *values* (e.g., whether
 * a `+` quantifier correctly becomes `min=1, max='Inf'`). This is
 * covered by other unit tests. This suite is concerned only with the
 * artifact's **structure**.
 * -   The performance of the validation process.
 */

// Note: Adjust import paths as needed for your project structure
import path from "path";
import { parseToArtifact } from "../../src/STRling/core/parser";
import {
    validateArtifact,
    ValidationError, // Assuming a custom error type
} from "../../src/STRling/core/validator";
// *** CORRECTED: Removed the non-existent 'artifact' import ***

// --- Test Suite Setup -----------------------------------------------------------

// Define a robust path to the schema files relative to this test file
// This assumes the test file is in a dir like `__tests__/unit`
const SPEC_DIR = path.resolve(
    __dirname,
    "..",
    "..",
    "..",
    "..",
    "spec",
    "schema"
);
const BASE_SCHEMA_PATH = path.join(SPEC_DIR, "base.schema.json");
const PCRE2_SCHEMA_PATH = path.join(SPEC_DIR, "pcre2.v1.schema.json");

// *** Omitted Python-specific registry setup, as it's not in the JS implementation ***

// --- Test Suite -----------------------------------------------------------------

describe("Category A: Positive Cases", () => {
    /**
     * Covers positive cases where valid artifacts are expected to pass validation.
     */

    test("should validate a minimal artifact", () => {
        /**
         * Tests that an artifact from a simple DSL string validates against the
         * base schema.
         */
        const artifact = parseToArtifact("a");
        // Expecting this function not to throw an error
        expect(() =>
            validateArtifact(artifact, BASE_SCHEMA_PATH)
        ).not.toThrow();
    });

    test("should validate a comprehensive artifact", () => {
        /**
         * Tests that an artifact from a complex DSL string using many node types
         * validates against the base schema.
         */
        const complexDsl =
            String.raw`%flags i,x` + String.raw`(?<A>a|b)? - (?<=\b) \d+ \k<A>`;
        const artifact = parseToArtifact(complexDsl);
        expect(() =>
            validateArtifact(artifact, BASE_SCHEMA_PATH)
        ).not.toThrow();
    });

    test("should validate a PCRE2-specific artifact", () => {
        /**
         * Tests that a valid artifact with PCRE2-specific fields validates
         * against the PCRE2 schema extension.
         */
        const artifact = parseToArtifact("a");
        // Manually add the PCRE2-specific fields
        artifact["emitter"] = "pcre2";
        artifact["compat"] = {
            variableLengthLookbehind: false,
            atomicGroups: true,
            unicodeProperties: true,
            ucpShorthandUsesUnicode: true,
            freeSpacing: true,
            absoluteAnchors: true,
        };
        expect(() =>
            validateArtifact(artifact, PCRE2_SCHEMA_PATH)
        ).not.toThrow();
    });
});

describe("Category B: Negative Cases", () => {
    /**
     * Covers negative cases where malformed artifacts are expected to fail
     * validation, confirming the validator is working correctly.
     */

    const baseArtifact = parseToArtifact("a");

    // Helper to merge artifact objects like the Python `|` operator
    // Using `any` to match the dynamic nature of the Python test
    const mergeArtifacts = (base: any, diff: any): any => {
        return { ...base, ...diff };
    };

    test.each<[any, string, string]>([
        // B.1: Missing a required top-level property
        [
            { version: "1.0.0", flags: {} },
            "'root' is a required property", // Python error
            "missing_root_property",
        ],
        // B.2: A property with the wrong data type
        [
            mergeArtifacts(baseArtifact, {
                flags: { ...baseArtifact.flags, ignoreCase: "true" },
            }),
            "is not of type 'boolean'", // Python error
            "wrong_property_type",
        ],
        // B.3: A node with an invalid enum value
        [
            mergeArtifacts(baseArtifact, {
                root: { kind: "Anchor", at: "InvalidPosition" },
            }),
            "is not valid under any of the given schemas", // Python error
            "invalid_enum_value",
        ],
        // B.4: A node with a missing required property
        [
            mergeArtifacts(baseArtifact, { root: { kind: "Lit" } }),
            "is not valid under any of the given schemas", // Python error
            "missing_node_property",
        ],
        // B.5: Additional, unexpected properties at the top level
        [
            mergeArtifacts(baseArtifact, { extraField: true }),
            "Additional properties are not allowed", // Python error
            "extra_top_level_property",
        ],
    ])(
        "should fail for artifact with %s (ID: %s)",
        (invalidArtifact, errorSubstring, id) => {
            /**
             * Tests that deliberately malformed artifacts raise a ValidationError
             * with a descriptive message.
             * Note: The exact error messages from jsonschema (Python) and ajv (JS)
             * may differ. We check for substrings that capture the *intent* of the error.
             */
            expect(() =>
                validateArtifact(invalidArtifact, BASE_SCHEMA_PATH)
            ).toThrow(ValidationError);
            try {
                validateArtifact(invalidArtifact, BASE_SCHEMA_PATH);
                fail("ValidationError was not thrown");
            } catch (e) {
                const err = e as Error; // Use base Error to check message

                // Loosened regex to catch common JS validator messages too
                const pyError = errorSubstring;
                const jsError = errorSubstring
                    .replace(
                        "'root' is a required property",
                        "must have required property 'root'"
                    )
                    .replace("is not of type 'boolean'", "must be boolean")
                    .replace(
                        "is not valid under any of the given schemas",
                        "must have required property|must be equal to one of the allowed values"
                    )
                    .replace(
                        "Additional properties are not allowed",
                        "must NOT have additional properties"
                    );

                const combinedRegex = new RegExp(`${pyError}|${jsError}`);
                expect(err.message).toMatch(combinedRegex);
            }
        }
    );
});

describe("Category C: Edge Cases", () => {
    /**
     * Covers edge cases for artifact validation.
     */

    test("should validate an artifact from an empty pattern", () => {
        /**
         * Tests that an artifact generated from an empty DSL string is valid.
         */
        const artifact = parseToArtifact("");
        expect(() =>
            validateArtifact(artifact, BASE_SCHEMA_PATH)
        ).not.toThrow();
    });

    test("should validate an artifact from a flags-only source", () => {
        /**
         * Tests that an artifact from a source with only a flags directive is valid.
         */
        const artifact = parseToArtifact("%flags i,m");
        expect(() =>
            validateArtifact(artifact, BASE_SCHEMA_PATH)
        ).not.toThrow();
    });
});
