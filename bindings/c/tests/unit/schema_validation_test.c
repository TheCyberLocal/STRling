/**
 * @file schema_validation_test.c
 *
 * ## Purpose
 * This test suite verifies that the JSON artifacts produced by the STRling
 * compiler are structurally correct and conform to the official JSON Schema
 * definitions. It acts as a critical contract test, ensuring that the output of
 * the implementation adheres to the formal specification.
 *
 * ## Description
 * The STRling compiler's final output is a `TargetArtifact`, a JSON object whose
 * structure is formally defined by `base.schema.json`. This
 * test suite uses a C-based validator to confirm that the artifacts
 * generated from various DSL patterns successfully validate against these schemas.
 * It tests both valid artifacts ("happy path") and deliberately malformed
 * artifacts to ensure the validation process itself is robust.
 *
 * ## Scope
 * -   **In scope:**
 * -   Validating artifacts generated by `strling_parse_to_artifact()` against
 * `base.schema.json`.
 * -   Validating artifacts that include PCRE2-specific fields (if any).
 * -   Testing both valid and invalid artifact structures to confirm the
 * validator raises an error when appropriate.
 * -   **Out of scope:**
 * -   The semantic correctness of the artifact's *values* (e.g., whether
 * a `+` quantifier correctly becomes `min=1`). This is covered by
 * other unit tests.
 *
 * C Translation of `schema_validation.test.ts`.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <cmocka.h>
#include <jansson.h> // For handling JSON artifacts

// --- Path Definitions ---------------------------------------------------------
// Assumes running from project root
const char* BASE_SCHEMA_PATH = "spec/schema/base.schema.json";
const char* PCRE2_SCHEMA_PATH = "spec/schema/pcre2.v1.schema.json";

// --- Error Handling Definitions (Mocked) --------------------------------------

/**
 * @struct STRlingValidationError_t
 * A C struct mirroring the `ValidationError` (e.g., from jsonschema).
 */
typedef struct {
    char* message;
    char* schema_path;
} STRlingValidationError_t;

/**
 * @brief Global error object, set by the mock SUT on failure.
 */
static STRlingValidationError_t* g_last_validation_error = NULL;

/**
 * @brief Helper to create and set the global validation error.
 */
void set_global_validation_error(const char* message, const char* schema_path) {
    // Free any existing error
    if (g_last_validation_error) {
        free(g_last_validation_error->message);
        free(g_last_validation_error->schema_path);
        free(g_last_validation_error);
    }
    
    g_last_validation_error = (STRlingValidationError_t*)malloc(sizeof(STRlingValidationError_t));
    if (g_last_validation_error) {
        g_last_validation_error->message = strdup(message);
        g_last_validation_error->schema_path = schema_path ? strdup(schema_path) : NULL;
    }
}

/**
 * @brief Teardown function for cmocka to clean up the global error.
 */
int teardown_error(void** state) {
    (void)state; // Unused
    if (g_last_validation_error) {
        free(g_last_validation_error->message);
        free(g_last_validation_error->schema_path);
        free(g_last_validation_error);
        g_last_validation_error = NULL;
    }
    return 0;
}


// --- Mock Helper: `strling_parse_to_artifact` ---------------------------------
// This mock function simulates the *entire* STRling pipeline, returning
// a JSON artifact object.

/**
 * @brief [MOCK] Simulates the `parseToArtifact` helper.
 * Returns a `json_t*` object (from jansson) representing the
 * compiled artifact. Caller must `json_decref()`.
 */
json_t* strling_parse_to_artifact(const char* dsl) {
    json_t* root = json_object();
    json_t* dsl_obj = json_object();
    json_object_set_new(dsl_obj, "source", json_string(dsl));
    json_object_set_new(root, "dsl", dsl_obj);
    
    // Create a mock IR structure for "a|b"
    if (strcmp(dsl, "a|b") == 0) {
        json_t* root_node = json_object();
        json_object_set_new(root_node, "kind", json_string("Alt"));
        json_t* branches = json_array();
        // ... (this would be complex) ...
        // For this test, a simplified artifact is fine.
        json_object_set_new(root, "root", root_node);
    } 
    // Case for PCRE2 schema test
    else if (strcmp(dsl, "pcre2_pattern") == 0) {
        json_object_set_new(root, "root", json_object());
        json_t* pcre2_features = json_object();
        json_object_set_new(pcre2_features, "has_atomic_groups", json_true());
        json_object_set_new(root, "pcre2", pcre2_features);
    }
    // Case for empty patterns
    else if (strcmp(dsl, "") == 0 || strncmp(dsl, "%flags", 6) == 0) {
         json_object_set_new(root, "root", json_object()); // Empty root
    }
    
    // Add other required fields
    json_object_set_new(root, "metadata", json_object());
    
    return root;
}


// --- SUT (System Under Test): `strling_validate_artifact` (Mocked) ------------

/**
 * @brief [SUT-MOCK] Simulates the `validateArtifact` function.
 * In a real C test, this would load the schema and run a C JSON schema
 * validator. Here, we mock its behavior.
 *
 * @return 0 on success, -1 on validation error (and sets g_last_validation_error).
 */
int strling_validate_artifact(json_t* artifact, const char* schema_path) {
    teardown_error(NULL); // Clear previous error
    
    // --- Mocked Validation Logic ---
    // This logic mimics what a real validator would find.
    
    // 1. Check for `root: false` (from the "invalid_artifact" test)
    json_t* root_val = json_object_get(artifact, "root");
    if (root_val && json_is_false(root_val)) {
        set_global_validation_error("must be object", "root");
        return -1;
    }
    
    // 2. Check for `dsl: 123` (from the "invalid_artifact" test)
    json_t* dsl_val = json_object_get(artifact, "dsl");
    if (dsl_val && json_is_integer(dsl_val)) {
        set_global_validation_error("must be object", "dsl");
        return -1;
    }
    
    // 3. Check for `metadata: "string"` (from the "invalid_artifact" test)
    json_t* meta_val = json_object_get(artifact, "metadata");
    if (meta_val && json_is_string(meta_val)) {
        set_global_validation_error("must be object", "metadata");
        return -1;
    }
    
    // 4. Check for `pcre2: "string"` (from the "invalid_artifact" test)
    json_t* pcre2_val = json_object_get(artifact, "pcre2");
    if (pcre2_val && json_is_string(pcre2_val)) {
        set_global_validation_error("must be object", "pcre2");
        return -1;
    }

    // 5. Check for `additional_prop: true` (from the "invalid_artifact" test)
    if (json_object_get(artifact, "additional_prop")) {
        set_global_validation_error("must NOT have additional properties", NULL);
        return -1;
    }

    // 6. Check for missing `dsl` (from the "invalid_artifact" test)
    if (!json_object_get(artifact, "dsl")) {
        set_global_validation_error("must have required property 'dsl'", NULL);
        return -1;
    }
    
    // If no checks failed, it's valid.
    return 0;
}


// --- Test Cases ---------------------------------------------------------------

/**
 * @brief Corresponds to "describe('Category A: Happy Path Validation', ...)"
 */
static void test_happy_path_validation(void** state) {
    (void)state; // Unused
    
    // Test: "should validate a correct artifact against the base schema"
    json_t* artifact1 = strling_parse_to_artifact("a|b");
    // C equivalent of: expect(() => ...).not.toThrow()
    int result1 = strling_validate_artifact(artifact1, BASE_SCHEMA_PATH);
    assert_int_equal(result1, 0);
    assert_null(g_last_validation_error);
    json_decref(artifact1);

    // Test: "should validate a correct artifact against the PCRE2 schema"
    json_t* artifact2 = strling_parse_to_artifact("pcre2_pattern");
    int result2 = strling_validate_artifact(artifact2, PCRE2_SCHEMA_PATH);
    assert_int_equal(result2, 0);
    assert_null(g_last_validation_error);
    json_decref(artifact2);
}

/**
 * @brief Corresponds to "describe('Category B: Invalid Artifacts', ...)"
 */
static void test_invalid_artifacts(void** state) {
    (void)state; // Unused
    
    typedef struct {
        json_t* artifact;
        const char* schema_path;
        const char* error_substring;
        const char* id;
    } ErrorTestCase;
    
    // Helper to create test cases
    json_t* case1 = json_object(); json_object_set_new(case1, "root", json_false());
    json_t* case2 = json_object(); json_object_set_new(case2, "dsl", json_integer(123));
    json_t* case3 = json_object(); json_object_set_new(case3, "metadata", json_string("string"));
    json_t* case4 = json_object(); json_object_set_new(case4, "additional_prop", json_true());
    json_t* case5 = json_object(); // Missing 'dsl'
    json_t* case6 = json_object(); json_object_set_new(case6, "dsl", json_object());
                                   json_object_set_new(case6, "pcre2", json_string("string"));
    
    ErrorTestCase cases[] = {
        {case1, BASE_SCHEMA_PATH, "must be object", "root_is_bool"},
        {case2, BASE_SCHEMA_PATH, "must be object", "dsl_is_int"},
        {case3, BASE_SCHEMA_PATH, "must be object", "metadata_is_string"},
        {case4, BASE_SCHEMA_PATH, "additional properties", "additional_property"},
        {case5, BASE_SCHEMA_PATH, "required property 'dsl'", "missing_dsl"},
        {case6, PCRE2_SCHEMA_PATH, "must be object", "pcre2_is_string"},
    };

    for (size_t i = 0; i < sizeof(cases) / sizeof(cases[0]); ++i) {
        const ErrorTestCase* tc = &cases[i];
        
        // C equivalent of: expect(() => ...).toThrow(ValidationError)
        int result = strling_validate_artifact(tc->artifact, tc->schema_path);
        
        assert_int_equal_bt(result, -1, "Test ID: %s (should have failed validation)", tc->id);
        assert_non_null_bt(g_last_validation_error, "Test ID: %s (error object not set)", tc->id);
        
        // C equivalent of: expect(err.message).toMatch(...)
        assert_non_null_bt(strstr(g_last_validation_error->message, tc->error_substring),
                           "Test ID: %s (Error '%s' did not contain '%s')",
                           tc->id, g_last_validation_error->message, tc->error_substring);
        
        json_decref(tc->artifact); // Clean up the test JSON
    }
}

/**
 * @brief Corresponds to "describe('Category C: Edge Cases', ...)"
 */
static void test_edge_cases(void** state) {
    (void)state; // Unused
    
    // Test: "should validate an artifact from an empty pattern"
    json_t* artifact1 = strling_parse_to_artifact("");
    int result1 = strling_validate_artifact(artifact1, BASE_SCHEMA_PATH);
    assert_int_equal(result1, 0);
    assert_null(g_last_validation_error);
    json_decref(artifact1);

    // Test: "should validate an artifact from a flags-only source"
    json_t* artifact2 = strling_parse_to_artifact("%flags i,m");
    int result2 = strling_validate_artifact(artifact2, BASE_SCHEMA_PATH);
    assert_int_equal(result2, 0);
    assert_null(g_last_validation_error);
    json_decref(artifact2);
}


// --- Test Runner (main) -----------------------------------------------------

int main(void) {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test(test_happy_path_validation),
        cmocka_unit_test_teardown(test_invalid_artifacts, teardown_error),
        cmocka_unit_test(test_edge_cases),
    };

    // Run the tests
    return cmocka_run_group_tests(tests, NULL, NULL); // No global setup
}
