/**
 * @file simply_api_test.c
 * @brief Unit Tests for Simply API Capabilities (54 Tests).
 *
 * PURPOSE:
 * Validates that the C library can compile the AST structures generated by the
 * high-level 'Simply' API (fluent builder). Since the C library does not expose
 * the builder itself, these tests verify the backend support for every Simply
 * function by compiling the equivalent JSON AST.
 *
 * MAPPING:
 * - Category A: Sets (12 tests) -> CharClass, Dot
 * - Category B: Constructors (11 tests) -> Seq, Alt, Quant, Group
 * - Category C: Lookarounds (4 tests) -> Lookaround
 * - Category D: Static/Anchors (10 tests) -> Anchor, BackRef, Atomic
 * - Category E: Recursion (3 tests) -> Recurse (future/simulated)
 * - Category F: Validation/Errors (5 tests) -> AST Validation
 * - Category G: Integration/Complex (9 tests) -> Real-world patterns
 */

#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <stdint.h>
#include <cmocka.h>
#include <string.h>
#include <stdio.h>

#include "strling.h"

// --- Test Infrastructure ----------------------------------------------------

static void verify_compile(const char *json_input, const char *expected_pcre) {
    strling_result_t result = strling_compile(json_input, NULL);
    
    if (result.error_code != STRling_OK) {
        printf("FAIL: Compilation error: %s\nInput: %s\n", result.error_message, json_input);
    }
    assert_int_equal(result.error_code, STRling_OK);
    assert_non_null(result.pcre2_pattern);
    
    if (strcmp(result.pcre2_pattern, expected_pcre) != 0) {
        printf("FAIL: Pattern mismatch.\nExpected: '%s'\nGot:      '%s'\n", 
               expected_pcre, result.pcre2_pattern);
    }
    assert_string_equal(result.pcre2_pattern, expected_pcre);
    
    strling_result_free(&result);
}

static void verify_error(const char *json_input, const char *expected_error_part) {
    strling_result_t result = strling_compile(json_input, NULL);
    
    assert_int_not_equal(result.error_code, STRling_OK);
    assert_non_null(result.error_message);
    if (strstr(result.error_message, expected_error_part) == NULL) {
        printf("FAIL: Error message mismatch.\nExpected part: '%s'\nGot: '%s'\n", 
               expected_error_part, result.error_message);
    }
    assert_non_null(strstr(result.error_message, expected_error_part));
    
    strling_result_free(&result);
}

// --- Category A: Sets (12 Tests) --------------------------------------------

static void test_set_any_of(void **state) {
    (void)state;
    // s.anyOf("abc") -> [abc]
    verify_compile("{\"type\": \"CharacterClass\", \"negated\": false, \"members\": [{\"type\": \"Literal\", \"value\": \"a\"}, {\"type\": \"Literal\", \"value\": \"b\"}, {\"type\": \"Literal\", \"value\": \"c\"}]}", "[abc]");
}

static void test_set_none_of(void **state) {
    (void)state;
    // s.noneOf("abc") -> [^abc]
    verify_compile("{\"type\": \"CharacterClass\", \"negated\": true, \"members\": [{\"type\": \"Literal\", \"value\": \"a\"}, {\"type\": \"Literal\", \"value\": \"b\"}, {\"type\": \"Literal\", \"value\": \"c\"}]}", "[^abc]");
}

static void test_set_range(void **state) {
    (void)state;
    // s.range("a", "z") -> [a-z]
    verify_compile("{\"type\": \"CharacterClass\", \"members\": [{\"type\": \"Range\", \"from\": \"a\", \"to\": \"z\"}]}", "[a-z]");
}

static void test_set_any(void **state) {
    (void)state;
    // s.any() -> .
    verify_compile("{\"type\": \"Dot\"}", ".");
}

static void test_set_digit(void **state) {
    (void)state;
    // s.digit() -> \d
    verify_compile("{\"type\": \"CharacterClass\", \"members\": [{\"type\": \"Escape\", \"kind\": \"digit\"}]}", "\\d");
}

static void test_set_whitespace(void **state) {
    (void)state;
    // s.whitespace() -> \s
    verify_compile("{\"type\": \"CharacterClass\", \"members\": [{\"type\": \"Escape\", \"kind\": \"whitespace\"}]}", "\\s");
}

static void test_set_word(void **state) {
    (void)state;
    // s.word() -> \w
    verify_compile("{\"type\": \"CharacterClass\", \"members\": [{\"type\": \"Escape\", \"kind\": \"word\"}]}", "\\w");
}

static void test_set_hex_digit(void **state) {
    (void)state;
    // s.hexDigit() -> [0-9a-fA-F] (Simulated via ranges)
    verify_compile("{\"type\": \"CharacterClass\", \"members\": [{\"type\": \"Range\", \"from\": \"0\", \"to\": \"9\"}, {\"type\": \"Range\", \"from\": \"a\", \"to\": \"f\"}, {\"type\": \"Range\", \"from\": \"A\", \"to\": \"F\"}]}", "[0-9a-fA-F]");
}

static void test_set_not_digit(void **state) {
    (void)state;
    // s.notDigit() -> \D
    verify_compile("{\"type\": \"CharacterClass\", \"negated\": true, \"members\": [{\"type\": \"Escape\", \"kind\": \"digit\"}]}", "\\D"); // Optimized output
}

static void test_set_not_whitespace(void **state) {
    (void)state;
    // s.notWhitespace() -> \S
    verify_compile("{\"type\": \"CharacterClass\", \"negated\": true, \"members\": [{\"type\": \"Escape\", \"kind\": \"whitespace\"}]}", "\\S");
}

static void test_set_not_word(void **state) {
    (void)state;
    // s.notWord() -> \W
    verify_compile("{\"type\": \"CharacterClass\", \"negated\": true, \"members\": [{\"type\": \"Escape\", \"kind\": \"word\"}]}", "\\W");
}

static void test_set_not_hex_digit(void **state) {
    (void)state;
    // s.notHexDigit() -> [^0-9a-fA-F]
    verify_compile("{\"type\": \"CharacterClass\", \"negated\": true, \"members\": [{\"type\": \"Range\", \"from\": \"0\", \"to\": \"9\"}, {\"type\": \"Range\", \"from\": \"a\", \"to\": \"f\"}, {\"type\": \"Range\", \"from\": \"A\", \"to\": \"F\"}]}", "[^0-9a-fA-F]");
}

// --- Category B: Constructors (11 Tests) ------------------------------------

static void test_ctor_literal(void **state) {
    (void)state;
    // s.literal("abc") -> abc
    verify_compile("{\"type\": \"Literal\", \"value\": \"abc\"}", "abc");
}

static void test_ctor_merge(void **state) {
    (void)state;
    // s.merge(a, b) -> ab
    verify_compile("{\"type\": \"Sequence\", \"parts\": [{\"type\": \"Literal\", \"value\": \"a\"}, {\"type\": \"Literal\", \"value\": \"b\"}]}", "ab");
}

static void test_ctor_alt(void **state) {
    (void)state;
    // s.any(a, b) -> a|b
    verify_compile("{\"type\": \"Alternation\", \"alternatives\": [{\"type\": \"Literal\", \"value\": \"a\"}, {\"type\": \"Literal\", \"value\": \"b\"}]}", "a|b");
}

static void test_ctor_optional(void **state) {
    (void)state;
    // s.optional(a) -> a?
    verify_compile("{\"type\": \"Quantifier\", \"min\": 0, \"max\": 1, \"greedy\": true, \"target\": {\"type\": \"Literal\", \"value\": \"a\"}}", "a?");
}

static void test_ctor_star(void **state) {
    (void)state;
    // s.zeroOrMore(a) -> a*
    verify_compile("{\"type\": \"Quantifier\", \"min\": 0, \"max\": null, \"greedy\": true, \"target\": {\"type\": \"Literal\", \"value\": \"a\"}}", "a*");
}

static void test_ctor_plus(void **state) {
    (void)state;
    // s.oneOrMore(a) -> a+
    verify_compile("{\"type\": \"Quantifier\", \"min\": 1, \"max\": null, \"greedy\": true, \"target\": {\"type\": \"Literal\", \"value\": \"a\"}}", "a+");
}

static void test_ctor_repeat_exact(void **state) {
    (void)state;
    // s.repeat(a, 3) -> a{3}
    verify_compile("{\"type\": \"Quantifier\", \"min\": 3, \"max\": 3, \"greedy\": true, \"target\": {\"type\": \"Literal\", \"value\": \"a\"}}", "a{3}");
}

static void test_ctor_repeat_min(void **state) {
    (void)state;
    // s.repeat(a, 3, null) -> a{3,}
    verify_compile("{\"type\": \"Quantifier\", \"min\": 3, \"max\": null, \"greedy\": true, \"target\": {\"type\": \"Literal\", \"value\": \"a\"}}", "a{3,}");
}

static void test_ctor_repeat_range(void **state) {
    (void)state;
    // s.repeat(a, 3, 5) -> a{3,5}
    verify_compile("{\"type\": \"Quantifier\", \"min\": 3, \"max\": 5, \"greedy\": true, \"target\": {\"type\": \"Literal\", \"value\": \"a\"}}", "a{3,5}");
}

static void test_ctor_capture(void **state) {
    (void)state;
    // s.capture(a) -> (a)
    verify_compile("{\"type\": \"Group\", \"capturing\": true, \"expression\": {\"type\": \"Literal\", \"value\": \"a\"}}", "(a)");
}

static void test_ctor_named_group(void **state) {
    (void)state;
    // s.group("name", a) -> (?<name>a)
    verify_compile("{\"type\": \"Group\", \"capturing\": true, \"name\": \"name\", \"expression\": {\"type\": \"Literal\", \"value\": \"a\"}}", "(?<name>a)");
}

// --- Category C: Lookarounds (4 Tests) --------------------------------------

static void test_look_ahead(void **state) {
    (void)state;
    // s.lookahead(a) -> (?=a)
    verify_compile("{\"type\": \"Lookaround\", \"kind\": \"lookahead\", \"negated\": false, \"expression\": {\"type\": \"Literal\", \"value\": \"a\"}}", "(?=a)");
}

static void test_look_neg_ahead(void **state) {
    (void)state;
    // s.negativeLookahead(a) -> (?!a)
    verify_compile("{\"type\": \"Lookaround\", \"kind\": \"lookahead\", \"negated\": true, \"expression\": {\"type\": \"Literal\", \"value\": \"a\"}}", "(?!a)");
}

static void test_look_behind(void **state) {
    (void)state;
    // s.lookbehind(a) -> (?<=a)
    verify_compile("{\"type\": \"Lookaround\", \"kind\": \"lookbehind\", \"negated\": false, \"expression\": {\"type\": \"Literal\", \"value\": \"a\"}}", "(?<=a)");
}

static void test_look_neg_behind(void **state) {
    (void)state;
    // s.negativeLookbehind(a) -> (?<!a)
    verify_compile("{\"type\": \"Lookaround\", \"kind\": \"lookbehind\", \"negated\": true, \"expression\": {\"type\": \"Literal\", \"value\": \"a\"}}", "(?<!a)");
}

// --- Category D: Static & Anchors (10 Tests) --------------------------------

static void test_static_atomic(void **state) {
    (void)state;
    // s.atomic(a) -> (?>a)
    verify_compile("{\"type\": \"Group\", \"atomic\": true, \"expression\": {\"type\": \"Literal\", \"value\": \"a\"}}", "(?>a)");
}

static void test_static_ref_index(void **state) {
    (void)state;
    // s.ref(1) -> \1
    verify_compile("{\"type\": \"BackReference\", \"kind\": \"numbered\", \"ref\": 1}", "\\1");
}

static void test_static_ref_name(void **state) {
    (void)state;
    // s.ref("name") -> \k<name>
    verify_compile("{\"type\": \"BackReference\", \"kind\": \"named\", \"name\": \"name\"}", "\\k<name>");
}

static void test_static_anchor_start(void **state) {
    (void)state;
    // s.start() -> ^
    verify_compile("{\"type\": \"Anchor\", \"at\": \"Start\"}", "^");
}

static void test_static_anchor_end(void **state) {
    (void)state;
    // s.end() -> $
    verify_compile("{\"type\": \"Anchor\", \"at\": \"End\"}", "$");
}

static void test_static_boundary(void **state) {
    (void)state;
    // s.boundary() -> \b
    verify_compile("{\"type\": \"Anchor\", \"at\": \"WordBoundary\"}", "\\b");
}

static void test_static_not_boundary(void **state) {
    (void)state;
    // s.notBoundary() -> \B
    verify_compile("{\"type\": \"Anchor\", \"at\": \"NotWordBoundary\"}", "\\B");
}

static void test_static_abs_start(void **state) {
    (void)state;
    // s.startOfString() -> \A
    verify_compile("{\"type\": \"Anchor\", \"at\": \"AbsoluteStart\"}", "\\A");
}

static void test_static_abs_end(void **state) {
    (void)state;
    // s.endOfString() -> \z
    verify_compile("{\"type\": \"Anchor\", \"at\": \"AbsoluteEndOnly\"}", "\\z"); // Or AbsoluteEnd
}

static void test_static_end_before_nl(void **state) {
    (void)state;
    // s.endBeforeNewline() -> \Z
    verify_compile("{\"type\": \"Anchor\", \"at\": \"EndBeforeFinalNewline\"}", "\\Z");
}

// --- Category E: Recursion (3 Tests) ----------------------------------------

static void test_recurse_pattern(void **state) {
    (void)state;
    // s.recursion() -> (?R) - if supported by emitter, or error if not
    // Assuming extended feature support
    verify_compile("{\"type\": \"BackReference\", \"kind\": \"recursion\"}", "(?R)");
}

static void test_subroutine_index(void **state) {
    (void)state;
    // s.subroutine(1) -> (?1)
    verify_compile("{\"type\": \"BackReference\", \"kind\": \"subroutine\", \"ref\": 1}", "(?1)");
}

static void test_subroutine_name(void **state) {
    (void)state;
    // s.subroutine("name") -> (?&name)
    verify_compile("{\"type\": \"BackReference\", \"kind\": \"subroutine\", \"name\": \"name\"}", "(?&name)");
}

// --- Category F: Validation Errors (5 Tests) --------------------------------

static void test_val_invalid_range(void **state) {
    (void)state;
    // Range min > max
    verify_error("{\"type\": \"Quantifier\", \"min\": 5, \"max\": 2, \"target\": {\"type\": \"Dot\"}}", "Invalid");
}

static void test_val_invalid_name(void **state) {
    (void)state;
    // Invalid group name
    verify_error("{\"type\": \"Group\", \"capturing\": true, \"name\": \"123invalid\", \"expression\": {\"type\": \"Dot\"}}", "Invalid group name");
}

static void test_val_empty_alt(void **state) {
    (void)state;
    // Alternation with 0 branches is invalid
    verify_error("{\"type\": \"Alternation\", \"alternatives\": []}", "Alternation");
}

static void test_val_negative_quant(void **state) {
    (void)state;
    // Negative min
    verify_error("{\"type\": \"Quantifier\", \"min\": -1, \"target\": {\"type\": \"Dot\"}}", "min");
}

static void test_val_missing_expression(void **state) {
    (void)state;
    // Group missing body
    verify_error("{\"type\": \"Group\", \"capturing\": true}", "expression");
}

// --- Category G: Integration & Complex (9 Tests) ----------------------------

static void test_int_email_simplified(void **state) {
    (void)state;
    // Simple email: \w+@\w+\.\w+
    verify_compile(
        "{\"type\": \"Sequence\", \"parts\": ["
            "{\"type\": \"Quantifier\", \"min\": 1, \"max\": null, \"greedy\": true, \"target\": {\"type\": \"CharacterClass\", \"members\": [{\"type\": \"Escape\", \"kind\": \"word\"}]}},"
            "{\"type\": \"Literal\", \"value\": \"@\"},"
            "{\"type\": \"Quantifier\", \"min\": 1, \"max\": null, \"greedy\": true, \"target\": {\"type\": \"CharacterClass\", \"members\": [{\"type\": \"Escape\", \"kind\": \"word\"}]}},"
            "{\"type\": \"Literal\", \"value\": \".\"},"
            "{\"type\": \"Quantifier\", \"min\": 1, \"max\": null, \"greedy\": true, \"target\": {\"type\": \"CharacterClass\", \"members\": [{\"type\": \"Escape\", \"kind\": \"word\"}]}}"
        "]}", 
        "\\w+@\\w+.\\w+");
}

static void test_int_nested_quantifiers(void **state) {
    (void)state;
    // (a+)+
    verify_compile(
        "{\"type\": \"Quantifier\", \"min\": 1, \"max\": null, \"greedy\": true, \"target\": "
            "{\"type\": \"Group\", \"capturing\": true, \"expression\": "
                "{\"type\": \"Quantifier\", \"min\": 1, \"max\": null, \"greedy\": true, \"target\": {\"type\": \"Literal\", \"value\": \"a\"}}}}",
        "(a+)+");
}

static void test_int_complex_alt(void **state) {
    (void)state;
    // (a|b|c)+
    verify_compile(
        "{\"type\": \"Quantifier\", \"min\": 1, \"max\": null, \"greedy\": true, \"target\": "
            "{\"type\": \"Group\", \"capturing\": true, \"expression\": "
                "{\"type\": \"Alternation\", \"alternatives\": ["
                    "{\"type\": \"Literal\", \"value\": \"a\"},"
                    "{\"type\": \"Literal\", \"value\": \"b\"},"
                    "{\"type\": \"Literal\", \"value\": \"c\"}"
                "]}}}",
        "(a|b|c)+");
}

static void test_int_atomic_lookaround(void **state) {
    (void)state;
    // (?> (?=a) b )
    verify_compile(
        "{\"type\": \"Group\", \"atomic\": true, \"expression\": "
            "{\"type\": \"Sequence\", \"parts\": ["
                "{\"type\": \"Lookaround\", \"kind\": \"lookahead\", \"negated\": false, \"expression\": {\"type\": \"Literal\", \"value\": \"a\"}},"
                "{\"type\": \"Literal\", \"value\": \"b\"}"
            "]}}",
        "(?>(?=a)b)");
}

static void test_int_named_backref_chain(void **state) {
    (void)state;
    // (?<x>a) \k<x>
    verify_compile(
        "{\"type\": \"Sequence\", \"parts\": ["
            "{\"type\": \"Group\", \"capturing\": true, \"name\": \"x\", \"expression\": {\"type\": \"Literal\", \"value\": \"a\"}},"
            "{\"type\": \"BackReference\", \"kind\": \"named\", \"name\": \"x\"}"
        "]}",
        "(?<x>a)\\k<x>");
}

static void test_int_flags_mixed(void **state) {
    (void)state;
    // Flags i, m + ^a$
    verify_compile(
        "{\"flags\": \"im\", \"pattern\": {\"type\": \"Sequence\", \"parts\": ["
            "{\"type\": \"Anchor\", \"at\": \"Start\"},"
            "{\"type\": \"Literal\", \"value\": \"a\"},"
            "{\"type\": \"Anchor\", \"at\": \"End\"}"
        "]}}",
        "(?im)^a$");
}

static void test_int_unicode_class(void **state) {
    (void)state;
    // [\p{L}\p{N}]
    verify_compile(
        "{\"type\": \"CharacterClass\", \"members\": ["
            "{\"type\": \"Escape\", \"kind\": \"unicode_property\", \"property\": \"L\"},"
            "{\"type\": \"Escape\", \"kind\": \"unicode_property\", \"property\": \"N\"}"
        "]}",
        "[\\p{L}\\p{N}]");
}

static void test_int_empty_pattern(void **state) {
    (void)state;
    // ""
    verify_compile("{\"type\": \"Sequence\", \"parts\": []}", "");
}

static void test_int_full_kitchen_sink(void **state) {
    (void)state;
    // (?:a|b)* \d+ ^ $
    verify_compile(
        "{\"type\": \"Sequence\", \"parts\": ["
            "{\"type\": \"Quantifier\", \"min\": 0, \"max\": null, \"greedy\": true, \"target\": "
                "{\"type\": \"Group\", \"capturing\": false, \"expression\": "
                    "{\"type\": \"Alternation\", \"alternatives\": ["
                        "{\"type\": \"Literal\", \"value\": \"a\"},"
                        "{\"type\": \"Literal\", \"value\": \"b\"}"
                    "]}}},"
            "{\"type\": \"Quantifier\", \"min\": 1, \"max\": null, \"greedy\": true, \"target\": "
                "{\"type\": \"CharacterClass\", \"members\": [{\"type\": \"Escape\", \"kind\": \"digit\"}]}},"
            "{\"type\": \"Anchor\", \"at\": \"Start\"},"
            "{\"type\": \"Anchor\", \"at\": \"End\"}"
        "]}",
        "(?:a|b)*\\d+^$");
}


int main(void) {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test(test_set_any_of),
        cmocka_unit_test(test_set_none_of),
        cmocka_unit_test(test_set_range),
        cmocka_unit_test(test_set_any),
        cmocka_unit_test(test_set_digit),
        cmocka_unit_test(test_set_whitespace),
        cmocka_unit_test(test_set_word),
        cmocka_unit_test(test_set_hex_digit),
        cmocka_unit_test(test_set_not_digit),
        cmocka_unit_test(test_set_not_whitespace),
        cmocka_unit_test(test_set_not_word),
        cmocka_unit_test(test_set_not_hex_digit),
        cmocka_unit_test(test_ctor_literal),
        cmocka_unit_test(test_ctor_merge),
        cmocka_unit_test(test_ctor_alt),
        cmocka_unit_test(test_ctor_optional),
        cmocka_unit_test(test_ctor_star),
        cmocka_unit_test(test_ctor_plus),
        cmocka_unit_test(test_ctor_repeat_exact),
        cmocka_unit_test(test_ctor_repeat_min),
        cmocka_unit_test(test_ctor_repeat_range),
        cmocka_unit_test(test_ctor_capture),
        cmocka_unit_test(test_ctor_named_group),
        cmocka_unit_test(test_look_ahead),
        cmocka_unit_test(test_look_neg_ahead),
        cmocka_unit_test(test_look_behind),
        cmocka_unit_test(test_look_neg_behind),
        cmocka_unit_test(test_static_atomic),
        cmocka_unit_test(test_static_ref_index),
        cmocka_unit_test(test_static_ref_name),
        cmocka_unit_test(test_static_anchor_start),
        cmocka_unit_test(test_static_anchor_end),
        cmocka_unit_test(test_static_boundary),
        cmocka_unit_test(test_static_not_boundary),
        cmocka_unit_test(test_static_abs_start),
        cmocka_unit_test(test_static_abs_end),
        cmocka_unit_test(test_static_end_before_nl),
        cmocka_unit_test(test_recurse_pattern),
        cmocka_unit_test(test_subroutine_index),
        cmocka_unit_test(test_subroutine_name),
        cmocka_unit_test(test_val_invalid_range),
        cmocka_unit_test(test_val_invalid_name),
        cmocka_unit_test(test_val_empty_alt),
        cmocka_unit_test(test_val_negative_quant),
        cmocka_unit_test(test_val_missing_expression),
        cmocka_unit_test(test_int_email_simplified),
        cmocka_unit_test(test_int_nested_quantifiers),
        cmocka_unit_test(test_int_complex_alt),
        cmocka_unit_test(test_int_atomic_lookaround),
        cmocka_unit_test(test_int_named_backref_chain),
        cmocka_unit_test(test_int_flags_mixed),
        cmocka_unit_test(test_int_unicode_class),
        cmocka_unit_test(test_int_empty_pattern),
        cmocka_unit_test(test_int_full_kitchen_sink),
    };
    return cmocka_run_group_tests(tests, NULL, NULL);
}
