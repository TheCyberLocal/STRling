"""
Test Design â€” test_schema_validation.py

## Purpose
This test suite verifies that the JSON artifacts produced by the STRling
compiler are structurally correct and conform to the official JSON Schema
definitions. It acts as a critical contract test, ensuring that the output of
the Python implementation adheres to the formal specification.

## Description
The STRling compiler's final output is a `TargetArtifact`, a JSON object whose
structure is formally defined by `base.schema.json` and its extensions (like
`pcre2.v1.schema.json`). This
test suite uses the `validator.py` utility to confirm that the artifacts
generated from various DSL patterns successfully validate against these schemas.
It tests both valid artifacts ("happy path") and deliberately malformed
artifacts to ensure the validation process itself is robust.

## Scope
-   **In scope:**
    -   Validating artifacts generated by `parse_to_artifact()` against
        `base.schema.json`.
    -   Validating artifacts that include PCRE2-specific fields against
        `pcre2.v1.schema.json`.
    -   Testing both valid and invalid artifact structures to confirm the
        validator raises `jsonschema.ValidationError` when appropriate
       .
-   **Out of scope:**
    -   The semantic correctness of the artifact's *values* (e.g., whether
        a `+` quantifier correctly becomes `min=1, max='Inf'`). This is
        covered by other unit tests. This suite is concerned only with the
        artifact's **structure**.
    -   The performance of the validation process.

"""

import pytest
from pathlib import Path
from typing import Dict, Any

from jsonschema.exceptions import ValidationError  # type: ignore

from STRling.core.parser import parse_to_artifact
from STRling.core.validator import validate_artifact

# --- Test Suite Setup -----------------------------------------------------------

# Define a robust path to the schema files relative to this test file
SPEC_DIR = Path(__file__).parent.parent.parent.parent / "spec/schema"
BASE_SCHEMA_PATH = str(SPEC_DIR / "base.schema.json")
PCRE2_SCHEMA_PATH = str(SPEC_DIR / "pcre2.v1.schema.json")


# --- Test Suite -----------------------------------------------------------------


class TestCategoryAPositiveCases:
    """
    Covers positive cases where valid artifacts are expected to pass validation.
    """

    def test_minimal_artifact_validates(self):
        """
        Tests that an artifact from a simple DSL string validates against the
        base schema.
        """
        artifact = parse_to_artifact("a")
        validate_artifact(artifact, BASE_SCHEMA_PATH)  # Should not raise

    def test_comprehensive_artifact_validates(self):
        """
        Tests that an artifact from a complex DSL string using many node types
        validates against the base schema.
        """
        complex_dsl = (
            r"%flags i,x"
            r"(?<A>a|b)? - (?<=\b) \d+ \k<A>"
        )
        artifact = parse_to_artifact(complex_dsl)
        validate_artifact(artifact, BASE_SCHEMA_PATH)  # Should not raise

    def test_pcre2_specific_artifact_validates(self):
        """
        Tests that a valid artifact with PCRE2-specific fields validates
        against the PCRE2 schema extension.
        """
        artifact = parse_to_artifact("a")
        # Manually add the PCRE2-specific fields
        artifact["emitter"] = "pcre2"
        artifact["compat"] = {
            "variableLengthLookbehind": False,
            "atomicGroups": True,
            "unicodeProperties": True,
            "ucpShorthandUsesUnicode": True,
            "freeSpacing": True,
            "absoluteAnchors": True,
        }
        validate_artifact(artifact, PCRE2_SCHEMA_PATH)  # Should not raise


class TestCategoryBNegativeCases:
    """
    Covers negative cases where malformed artifacts are expected to fail
    validation, confirming the validator is working correctly.
    """

    @pytest.mark.parametrize(
        "invalid_artifact, error_substring",
        [
            # B.1: Missing a required top-level property
            (
                {"version": "1.0.0", "flags": {}},
                "'root' is a required property",
            ),
            # B.2: A property with the wrong data type
            (
                parse_to_artifact("a") | {"flags": {"ignoreCase": "true"}},
                "'true' is not of type 'boolean'",
            ),
            # B.3: A node with an invalid enum value
            (
                parse_to_artifact("a")
                | {"root": {"kind": "Anchor", "at": "InvalidPosition"}},
                "'InvalidPosition' is not one of",
            ),
            # B.4: A node with a missing required property
            (
                parse_to_artifact("a") | {"root": {"kind": "Lit"}},
                "'value' is a required property",
            ),
            # B.5: Additional, unexpected properties at the top level
            (
                parse_to_artifact("a") | {"extraField": True},
                "Additional properties are not allowed",
            ),
        ],
        ids=[
            "missing_root_property",
            "wrong_property_type",
            "invalid_enum_value",
            "missing_node_property",
            "extra_top_level_property",
        ],
    )
    def test_invalid_artifacts_raise_validation_error(
        self, invalid_artifact: Dict[str, Any], error_substring: str
    ):
        """

        Tests that deliberately malformed artifacts raise a ValidationError
        with a descriptive message.
        """
        with pytest.raises(ValidationError) as excinfo:
            validate_artifact(invalid_artifact, BASE_SCHEMA_PATH)
        assert error_substring in str(excinfo.value)


class TestCategoryCEdgeCases:
    """
    Covers edge cases for artifact validation.
    """

    def test_empty_pattern_artifact_validates(self):
        """
        Tests that an artifact generated from an empty DSL string is valid.
        """
        artifact = parse_to_artifact("")
        validate_artifact(artifact, BASE_SCHEMA_PATH)

    def test_flags_only_artifact_validates(self):
        """
        Tests that an artifact from a source with only a flags directive is valid.
        """
        artifact = parse_to_artifact("%flags i,m")
        validate_artifact(artifact, BASE_SCHEMA_PATH)
