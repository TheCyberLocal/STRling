"""
Test Design â€” test_schema_validation.py

## Purpose
This test suite verifies that the JSON artifacts produced by the STRling
compiler are structurally correct and conform to the official JSON Schema
definitions. It acts as a critical contract test, ensuring that the output of
the Python implementation adheres to the formal specification.

## Description
The STRling compiler's final output is a `TargetArtifact`, a JSON object whose
structure is formally defined by `base.schema.json` and its extensions (like
`pcre2.v1.schema.json`). This
test suite uses the `validator.py` utility to confirm that the artifacts
generated from various DSL patterns successfully validate against these schemas.
It tests both valid artifacts ("happy path") and deliberately malformed
artifacts to ensure the validation process itself is robust.

## Scope
-   **In scope:**
    -   Validating artifacts generated by `parse_to_artifact()` against
        `base.schema.json`.
    -   Validating artifacts that include PCRE2-specific fields against
        `pcre2.v1.schema.json`.
    -   Testing both valid and invalid artifact structures to confirm the
        validator raises `jsonschema.ValidationError` when appropriate
       .
-   **Out of scope:**
    -   The semantic correctness of the artifact's *values* (e.g., whether
        a `+` quantifier correctly becomes `min=1, max='Inf'`). This is
        covered by other unit tests. This suite is concerned only with the
        artifact's **structure**.
    -   The performance of the validation process.

"""

import pytest
from pathlib import Path
from typing import Dict, Any

import json

from jsonschema.exceptions import ValidationError
from referencing import Registry, Resource

from STRling.core.parser import parse_to_artifact
from STRling.core.validator import validate_artifact

# --- Test Suite Setup -----------------------------------------------------------

# Define a robust path to the schema files relative to this test file
SPEC_DIR = Path(__file__).parent.parent.parent.parent.parent / "spec" / "schema"
BASE_SCHEMA_PATH = SPEC_DIR / "base.schema.json"
PCRE2_SCHEMA_PATH = SPEC_DIR / "pcre2.v1.schema.json"

# Define the schema IDs from the $id fields in the JSON files
BASE_SCHEMA_ID = "https://strling.dev/schema/base.schema.json"
PCRE2_SCHEMA_ID = "https://strling.dev/schema/pcre2.v1.schema.json"

# Load schema contents into Resource objects
base_schema_resource = Resource.from_contents(
    json.loads(BASE_SCHEMA_PATH.read_text(encoding="utf-8"))
)
pcre2_schema_resource = Resource.from_contents(
    json.loads(PCRE2_SCHEMA_PATH.read_text(encoding="utf-8"))
)

# Create a registry that maps the network URLs to our local file resources
test_registry = Registry().with_resources(
    [
        (BASE_SCHEMA_ID, base_schema_resource),
        (PCRE2_SCHEMA_ID, pcre2_schema_resource),
    ]
)

# --- Test Suite -----------------------------------------------------------------


class TestCategoryAPositiveCases:
    """
    Covers positive cases where valid artifacts are expected to pass validation.
    """

    def test_minimal_artifact_validates(self):
        """
        Tests that an artifact from a simple DSL string validates against the
        base schema.
        """
        artifact = parse_to_artifact("a")
        validate_artifact(artifact, str(BASE_SCHEMA_PATH), registry=test_registry)

    def test_comprehensive_artifact_validates(self):
        """
        Tests that an artifact from a complex DSL string using many node types
        validates against the base schema.
        """
        complex_dsl = (
            r"%flags i,x"
            r"(?<A>a|b)? - (?<=\b) \d+ \k<A>"
        )
        artifact = parse_to_artifact(complex_dsl)
        validate_artifact(artifact, str(BASE_SCHEMA_PATH), registry=test_registry)

    def test_pcre2_specific_artifact_validates(self):
        """
        Tests that a valid artifact with PCRE2-specific fields validates
        against the PCRE2 schema extension.
        """
        artifact = parse_to_artifact("a")
        # Manually add the PCRE2-specific fields
        artifact["emitter"] = "pcre2"
        artifact["compat"] = {
            "variableLengthLookbehind": False,
            "atomicGroups": True,
            "unicodeProperties": True,
            "ucpShorthandUsesUnicode": True,
            "freeSpacing": True,
            "absoluteAnchors": True,
        }
        validate_artifact(artifact, str(PCRE2_SCHEMA_PATH), registry=test_registry)


class TestCategoryBNegativeCases:
    """
    Covers negative cases where malformed artifacts are expected to fail
    validation, confirming the validator is working correctly.
    """

    @pytest.mark.parametrize(
        "invalid_artifact, error_substring",
        [
            # B.1: Missing a required top-level property
            (
                {"version": "1.0.0", "flags": {}},
                "'root' is a required property",
            ),
            # B.2: A property with the wrong data type
            (
                parse_to_artifact("a") | {"flags": {"ignoreCase": "true"}},
                "'true' is not of type 'boolean'",
            ),
            # B.3: A node with an invalid enum value
            (
                parse_to_artifact("a")
                | {"root": {"kind": "Anchor", "at": "InvalidPosition"}},
                "is not valid under any of the given schemas",
            ),
            # B.4: A node with a missing required property
            (
                parse_to_artifact("a") | {"root": {"kind": "Lit"}},
                "is not valid under any of the given schemas",
            ),
            # B.5: Additional, unexpected properties at the top level
            (
                parse_to_artifact("a") | {"extraField": True},
                "Additional properties are not allowed",
            ),
        ],
        ids=[
            "missing_root_property",
            "wrong_property_type",
            "invalid_enum_value",
            "missing_node_property",
            "extra_top_level_property",
        ],
    )
    def test_invalid_artifacts_raise_validation_error(
        self, invalid_artifact: Dict[str, Any], error_substring: str
    ):
        """

        Tests that deliberately malformed artifacts raise a ValidationError
        with a descriptive message.
        """
        with pytest.raises(ValidationError) as excinfo:
            validate_artifact(
                invalid_artifact, str(BASE_SCHEMA_PATH), registry=test_registry
            )
        assert error_substring in str(excinfo.value)


class TestCategoryCEdgeCases:
    """
    Covers edge cases for artifact validation.
    """

    def test_empty_pattern_artifact_validates(self):
        """
        Tests that an artifact generated from an empty DSL string is valid.
        """
        artifact = parse_to_artifact("")
        validate_artifact(artifact, str(BASE_SCHEMA_PATH), registry=test_registry)

    def test_flags_only_artifact_validates(self):
        """
        Tests that an artifact from a source with only a flags directive is valid.
        """
        artifact = parse_to_artifact("%flags i,m")
        validate_artifact(artifact, str(BASE_SCHEMA_PATH), registry=test_registry)
