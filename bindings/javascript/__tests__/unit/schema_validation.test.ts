/**
 * @file Test Design â€” schema_validation.test.ts
 *
 * ## Purpose
 * This test suite verifies that the JSON artifacts produced by the STRling
 * compiler are structurally correct and conform to the official JSON Schema
 * definitions. It acts as a critical contract test, ensuring that the output of
 * the implementation adheres to the formal specification.
 *
 * ## Description
 * The STRling compiler's final output is a `TargetArtifact`, a JSON object whose
 * structure is formally defined by `base.schema.json` and its extensions (like
 * `pcre2.v1.schema.json`). This test suite uses the `validator` utility to
 * confirm that the artifacts generated from various DSL patterns successfully
 * validate against these schemas. It tests both valid artifacts ("happy path")
 * and deliberately malformed artifacts to ensure the validation process itself is robust.
 *
 * ## Scope
 * -   **In scope:**
 * -   Validating artifacts generated by `parseToArtifact()` against
 * `base.schema.json`.
 * -   Validating artifacts that include PCRE2-specific fields against
 * `pcre2.v1.schema.json`.
 * -   Testing both valid and invalid artifact structures to confirm the
 * validator raises a `ValidationError` when appropriate.
 * -   **Out of scope:**
 * -   The semantic correctness of the artifact's *values* (e.g., whether
 * a `+` quantifier correctly becomes `min=1, max='Inf'`). This is
 * covered by other unit tests. This suite is concerned only with the
 * artifact's **structure**.
 * -   The performance of the validation process.
 */

// Note: This test assumes a TypeScript implementation of `validateArtifact`
// that uses a library like `ajv` and throws a custom `ValidationError`.
import path from "path";
import { parseToArtifact } from "../../src/STRling/core/parser";
import {
    validateArtifact,
    ValidationError,
} from "../../src/STRling/core/validator";

// --- Test Suite Setup -----------------------------------------------------------

// Define a robust path to the schema files relative to this test file
const SPEC_DIR = path.join(__dirname, "../../../../spec/schema");
const BASE_SCHEMA_PATH = path.join(SPEC_DIR, "base.schema.json");
const PCRE2_SCHEMA_PATH = path.join(SPEC_DIR, "pcre2.v1.schema.json");

// --- Test Suite -----------------------------------------------------------------

describe("Category A: Positive Cases", () => {
    /**
     * Covers positive cases where valid artifacts are expected to pass validation.
     *
     */

    test("should validate a minimal artifact", () => {
        /**
         * Tests that an artifact from a simple DSL string validates against the
         * base schema.
         */
        const artifact = parseToArtifact("a");
        // Expecting this function not to throw an error
        expect(() =>
            validateArtifact(artifact, BASE_SCHEMA_PATH)
        ).not.toThrow();
    });

    test("should validate a comprehensive artifact", () => {
        /**
         * Tests that an artifact from a complex DSL string using many node types
         * validates against the base schema.
         */
        const complexDsl = "%flags i,x\n(?<A>a|b)? - (?<=\\b) \\d+ \\k<A>";
        const artifact = parseToArtifact(complexDsl);
        expect(() =>
            validateArtifact(artifact, BASE_SCHEMA_PATH)
        ).not.toThrow();
    });

    test("should validate a PCRE2-specific artifact", () => {
        /**
         * Tests that a valid artifact with PCRE2-specific fields validates
         * against the PCRE2 schema extension.
         */
        const artifact = parseToArtifact("a");
        // Manually add the PCRE2-specific fields
        artifact.emitter = "pcre2";
        artifact.compat = {
            variableLengthLookbehind: false,
            atomicGroups: true,
            unicodeProperties: true,
            ucpShorthandUsesUnicode: true,
            freeSpacing: true,
            absoluteAnchors: true,
        };
        expect(() =>
            validateArtifact(artifact, PCRE2_SCHEMA_PATH)
        ).not.toThrow();
    });
});

describe("Category B: Negative Cases", () => {
    /**
     * Covers negative cases where malformed artifacts are expected to fail
     * validation, confirming the validator is working correctly.
     *
     */

    const baseArtifact = parseToArtifact("a");

    test.each<[Record<string, any>, string, string]>([
        // B.1: Missing a required top-level property
        [
            { version: "1.0.0", flags: {} },
            "must have required property 'root'",
            "missing_root_property",
        ],
        // B.2: A property with the wrong data type
        [
            {
                ...baseArtifact,
                flags: { ...baseArtifact.flags, ignoreCase: "true" },
            },
            "must be boolean",
            "wrong_property_type",
        ],
        // B.3: A node with an invalid enum value
        [
            {
                ...baseArtifact,
                root: { kind: "Anchor", at: "InvalidPosition" },
            },
            "must be equal to one of the allowed values",
            "invalid_enum_value",
        ],
        // B.4: A node with a missing required property
        [
            { ...baseArtifact, root: { kind: "Lit" } },
            "must have required property 'value'",
            "missing_node_property",
        ],
        // B.5: Additional, unexpected properties at the top level
        [
            { ...baseArtifact, extraField: true },
            "must NOT have additional properties",
            "extra_top_level_property",
        ],
    ])(
        "should fail for artifact with %s",
        (invalidArtifact, errorSubstring) => {
            /**
             * Tests that deliberately malformed artifacts raise a ValidationError
             * with a descriptive message.
             */
            expect(() =>
                validateArtifact(invalidArtifact, BASE_SCHEMA_PATH)
            ).toThrow(ValidationError);
            expect(() =>
                validateArtifact(invalidArtifact, BASE_SCHEMA_PATH)
            ).toThrow(errorSubstring);
        }
    );
});

describe("Category C: Edge Cases", () => {
    /**
     * Covers edge cases for artifact validation.
     *
     */

    test("should validate an artifact from an empty pattern", () => {
        /**
         * Tests that an artifact generated from an empty DSL string is valid.
         *
         */
        const artifact = parseToArtifact("");
        expect(() =>
            validateArtifact(artifact, BASE_SCHEMA_PATH)
        ).not.toThrow();
    });

    test("should validate an artifact from a flags-only source", () => {
        /**
         * Tests that an artifact from a source with only a flags directive is valid.
         *
         */
        const artifact = parseToArtifact("%flags i,m");
        expect(() =>
            validateArtifact(artifact, BASE_SCHEMA_PATH)
        ).not.toThrow();
    });
});
