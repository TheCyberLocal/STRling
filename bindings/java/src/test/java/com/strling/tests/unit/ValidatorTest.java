package com.strling.tests.unit;

import com.strling.core.Parser;
import com.strling.core.Validator;
import com.strling.core.Validator.ValidationError;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test Design â€” ValidatorTest.java
 *
 * <h2>Purpose</h2>
 * This test suite verifies that the JSON artifacts produced by the STRling
 * compiler are structurally correct and conform to the official JSON Schema
 * definitions. It acts as a critical contract test, ensuring that the output of
 * the implementation adheres to the formal specification.
 *
 * <h2>Description</h2>
 * The STRling compiler's final output is a {@code TargetArtifact}, a JSON object whose
 * structure is formally defined by {@code base.schema.json} and its extensions (like
 * {@code pcre2.v1.schema.json}). This
 * test suite uses the {@code Validator} utility to confirm that the artifacts
 * generated from various DSL patterns successfully validate against these schemas.
 * It tests both valid artifacts ("happy path") and deliberately malformed
 * artifacts to ensure the validation process itself is robust.
 *
 * <h2>Scope</h2>
 * <ul>
 *   <li><strong>In scope:</strong></li>
 *   <ul>
 *     <li>Validating artifacts generated by {@code parseToArtifact()} against
 *         {@code base.schema.json}.</li>
 *     <li>Validating artifacts that include PCRE2-specific fields against
 *         {@code pcre2.v1.schema.json}.</li>
 *     <li>Testing both valid and invalid artifact structures to confirm the
 *         validator raises {@code ValidationError} when appropriate.</li>
 *   </ul>
 *   <li><strong>Out of scope:</strong></li>
 *   <ul>
 *     <li>The semantic correctness of the artifact's <em>values</em> (e.g., whether
 *         a {@code +} quantifier correctly becomes {@code min=1, max='Inf'}). This is
 *         covered by other unit tests. This suite is concerned only with the
 *         artifact's <strong>structure</strong>.</li>
 *     <li>The performance of the validation process.</li>
 *   </ul>
 * </ul>
 */
public class ValidatorTest {
    
    // Define robust paths to the schema files relative to the project root
    private static final String SPEC_DIR = Paths.get("").toAbsolutePath()
            .getParent().getParent().resolve("spec/schema").toString();
    private static final String BASE_SCHEMA_PATH = Paths.get(SPEC_DIR, "base.schema.json").toString();
    private static final String PCRE2_SCHEMA_PATH = Paths.get(SPEC_DIR, "pcre2.v1.schema.json").toString();
    
    /**
     * Category A: Positive Cases
     * <p>
     * Covers positive cases where valid artifacts are expected to pass validation.
     */
    
    @Test
    void testValidateMinimalArtifact() {
        /**
         * Tests that an artifact from a simple DSL string validates against the
         * base schema.
         */
        Map<String, Object> artifact = Parser.parseToArtifact("a");
        assertDoesNotThrow(() -> Validator.validateArtifact(artifact, BASE_SCHEMA_PATH),
            "Minimal artifact should validate successfully");
    }
    
    @Test
    void testValidateComprehensiveArtifact() {
        /**
         * Tests that an artifact from a complex DSL string using many node types
         * validates against the base schema.
         */
        String complexDsl = "%flags i,x" + "(?<A>a|b)? - (?<=\\b) \\d+ \\k<A>";
        Map<String, Object> artifact = Parser.parseToArtifact(complexDsl);
        assertDoesNotThrow(() -> Validator.validateArtifact(artifact, BASE_SCHEMA_PATH),
            "Comprehensive artifact should validate successfully");
    }
    
    @Test
    void testValidatePcre2SpecificArtifact() {
        /**
         * Tests that a valid artifact with PCRE2-specific fields validates
         * against the PCRE2 schema extension.
         */
        Map<String, Object> artifact = Parser.parseToArtifact("a");
        // Manually add the PCRE2-specific fields
        artifact.put("emitter", "pcre2");
        Map<String, Object> compat = new HashMap<>();
        compat.put("variableLengthLookbehind", false);
        compat.put("atomicGroups", true);
        compat.put("unicodeProperties", true);
        compat.put("ucpShorthandUsesUnicode", true);
        compat.put("freeSpacing", true);
        compat.put("absoluteAnchors", true);
        artifact.put("compat", compat);
        
        assertDoesNotThrow(() -> Validator.validateArtifact(artifact, PCRE2_SCHEMA_PATH),
            "PCRE2-specific artifact should validate successfully");
    }
    
    /**
     * Category B: Negative Cases
     * <p>
     * Covers negative cases where malformed artifacts are expected to fail
     * validation, confirming the validator is working correctly.
     */
    
    // Helper to merge artifact objects
    private Map<String, Object> mergeArtifacts(Map<String, Object> base, Map<String, Object> diff) {
        Map<String, Object> result = new HashMap<>(base);
        result.putAll(diff);
        return result;
    }
    
    static Stream<Arguments> invalidArtifactTestCases() {
        Map<String, Object> baseArtifact = Parser.parseToArtifact("a");
        
        return Stream.of(
            // B.1: Missing a required top-level property
            Arguments.of(
                createMap("version", "1.0.0", "flags", createMap()),
                "root",
                "missing_root_property"
            ),
            // B.2: A property with the wrong data type
            Arguments.of(
                mergeWith(baseArtifact, "flags", 
                    mergeWith((Map<String, Object>) baseArtifact.get("flags"), "ignoreCase", "true")),
                "boolean",
                "wrong_property_type"
            ),
            // B.3: A node with an invalid enum value
            Arguments.of(
                mergeWith(baseArtifact, "root",
                    createMap("kind", "Anchor", "at", "InvalidPosition")),
                "enum",
                "invalid_enum_value"
            ),
            // B.4: A node with a missing required property
            Arguments.of(
                mergeWith(baseArtifact, "root", createMap("kind", "Lit")),
                "required",
                "missing_node_property"
            ),
            // B.5: Additional, unexpected properties at the top level
            Arguments.of(
                mergeWith(baseArtifact, "extraField", true),
                "additional",
                "extra_top_level_property"
            )
        );
    }
    
    @ParameterizedTest(name = "should fail for artifact with {2}")
    @MethodSource("invalidArtifactTestCases")
    void testInvalidArtifacts(Map<String, Object> invalidArtifact, String errorSubstring, String id) {
        /**
         * Tests that deliberately malformed artifacts raise a ValidationError
         * with a descriptive message.
         */
        ValidationError exception = assertThrows(ValidationError.class,
            () -> Validator.validateArtifact(invalidArtifact, BASE_SCHEMA_PATH),
            "Invalid artifact should fail validation");
        
        String message = exception.getMessage().toLowerCase();
        assertTrue(message.contains(errorSubstring.toLowerCase()),
            "Error message should contain '" + errorSubstring + "' but was: " + exception.getMessage());
    }
    
    /**
     * Category C: Edge Cases
     * <p>
     * Covers edge cases for artifact validation.
     */
    
    @Test
    void testValidateArtifactFromEmptyPattern() {
        /**
         * Tests that an artifact generated from an empty DSL string is valid.
         */
        Map<String, Object> artifact = Parser.parseToArtifact("");
        assertDoesNotThrow(() -> Validator.validateArtifact(artifact, BASE_SCHEMA_PATH),
            "Artifact from empty pattern should validate successfully");
    }
    
    @Test
    void testValidateArtifactFromFlagsOnlySource() {
        /**
         * Tests that an artifact from a source with only a flags directive is valid.
         */
        Map<String, Object> artifact = Parser.parseToArtifact("%flags i,m");
        assertDoesNotThrow(() -> Validator.validateArtifact(artifact, BASE_SCHEMA_PATH),
            "Artifact from flags-only pattern should validate successfully");
    }
    
    // Helper methods for creating test data
    private static Map<String, Object> createMap(Object... keyValues) {
        Map<String, Object> map = new HashMap<>();
        for (int i = 0; i < keyValues.length; i += 2) {
            map.put((String) keyValues[i], keyValues[i + 1]);
        }
        return map;
    }
    
    private static Map<String, Object> mergeWith(Map<String, Object> base, String key, Object value) {
        Map<String, Object> result = new HashMap<>(base);
        result.put(key, value);
        return result;
    }
}
