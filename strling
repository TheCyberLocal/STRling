#!/bin/bash
set -o pipefail

# Resolve script directory to locate toolchain.json
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
TOOLCHAIN="$DIR/toolchain.json"

# Where python virtualenv will live when using python binding
VENV_DIR=".venv"

COMMAND=$1
LANG=$2

# Help / Usage
if [ -z "$COMMAND" ] || [ -z "$LANG" ]; then
    echo "Usage: ./strling <command> <language>"
    echo "Commands: setup, test, build"
    echo "Example: ./strling test python"
    exit 1
fi

if [ ! -f "$TOOLCHAIN" ]; then
    echo "Error: toolchain.json not found at $TOOLCHAIN"
    exit 1
fi

# Check for python3
if ! command -v python3 &> /dev/null; then
    echo "Error: python3 is required to parse toolchain.json"
    exit 1
fi

# Handle 'setup all' command
if [ "$COMMAND" == "setup" ] && [ "$LANG" == "all" ]; then
    echo ">> WARNING: You're about to run setup for ALL bindings (this will install toolchains for 17+ languages and may consume significant disk space and take considerable time)."
    echo ">> Recommended: run a binding-specific setup instead, e.g. ./strling setup python"

    # Refuse to run in a non-interactive shell to avoid accidental usage in CI
    if [ ! -t 0 ]; then
        echo "Error: non-interactive shell detected. Aborting 'setup all'."
        echo "Run './strling setup <lang>' for a single binding instead."
        exit 1
    fi

    # Ask user to confirm explicitly
    read -p "Are you sure you want to continue? Type 'yes' to proceed: " CONFIRM
    if [[ "$CONFIRM" != "yes" ]]; then
        echo "Aborting 'setup all'. No changes made. Use './strling setup <lang>' for a single binding."
        exit 1
    fi

    echo ">> Running setup for ALL bindings..."

    # Get list of languages
    LANGS=$(python3 -c "import json; print(' '.join(json.load(open('$TOOLCHAIN'))['bindings'].keys()))")

    for L in $LANGS; do
        echo "--------------------------------------------------"
        echo ">> Setting up $L..."
        "$0" setup "$L"
    done
    exit 0
fi

# Handle 'clean' command
if [ "$COMMAND" == "clean" ]; then
    if [ "$LANG" == "all" ]; then
        echo ">> Cleaning global artifacts..."
        # Remove common build directories recursively
        find "$DIR" -type d \( -name "build" -o -name "target" -o -name "dist" -o -name "vendor" -o -name "__pycache__" -o -name ".venv" -o -name ".pytest_cache" -o -name ".mypy_cache" \) -prune -exec rm -rf {} +
        echo ">> Global clean complete."
        exit 0
    else
        echo ">> Cleaning $LANG..."
        # For specific language, we might want to look up a clean command or just clean its directory
        # But for now, the requirement is mostly about the global clean.
        # Let's just warn that specific clean is not fully implemented or just do a targeted clean if we knew the path.
        # We can use the path from toolchain.
        
        # We need to fetch the path first, which happens below.
        # So we let it fall through to the normal logic? 
        # But toolchain.json doesn't have a 'clean' command.
        # So we should handle it here.
        
        # Let's fetch the path using the helper (we need to define it first or move this block down)
        # The helper is defined below. Let's move the helper up or duplicate logic?
        # Better to move the helper up.
        # But I can't easily move code with replace_string.
        # I'll just use the python one-liner again.
        
        BINDING_PATH=$(python3 -c "import json; try: print(json.load(open('$TOOLCHAIN'))['bindings']['$LANG']['path']); except: pass")
        if [ -z "$BINDING_PATH" ]; then
             echo "Error: Language '$LANG' not found in toolchain.json"
             exit 1
        fi
        
        TARGET_DIR="$DIR/$BINDING_PATH"
        echo ">> Cleaning artifacts in $TARGET_DIR..."
        find "$TARGET_DIR" -type d \( -name "build" -o -name "target" -o -name "dist" -o -name "vendor" -o -name "__pycache__" -o -name ".venv" \) -prune -exec rm -rf {} +
        echo ">> Clean complete for $LANG."
        exit 0
    fi
fi

# Helper to get value from JSON
get_json_value() {
    local key="$1"
    python3 - <<PY
import json
try:
    data=json.load(open('$TOOLCHAIN'))
    b=data['bindings'].get('$LANG', {})
    val=b.get('$key','')
    if isinstance(val, list):
        print(' '.join(val))
    else:
        print(val)
except Exception:
    pass
PY
}

# Helper to get command string from JSON (properly quoted)
get_cmd_string() { get_json_value "$1"; }

BINDING_PATH=$(get_json_value "path")
CHECK_BIN=$(get_json_value "check_bin")

if [ -z "$BINDING_PATH" ]; then
    echo "Error: Language '$LANG' not found in toolchain.json"
    exit 1
fi

# Check if the required binary exists
# Check for required binary
if ! command -v "$CHECK_BIN" &> /dev/null; then
    echo "Error: Required tool '$CHECK_BIN' not found. Please install it to work with $LANG."
    exit 1
fi

CMD_STRING=$(get_cmd_string "$COMMAND")

if [ -z "$CMD_STRING" ]; then
    echo "No '$COMMAND' command defined for $LANG."
    exit 0
fi

echo ">> Running $COMMAND for $LANG in $BINDING_PATH..."

cd "$DIR/$BINDING_PATH" || exit 1

# Python: create & use venv so pip doesn't try to write system files
if [[ "$LANG" == "python" ]]; then
    if [[ ! -d "$VENV_DIR" ]]; then
        echo ">> Creating Python virtual environment..."
        python3 -m venv "$VENV_DIR"
    fi
    export PATH="$(pwd)/$VENV_DIR/bin:$PATH"
    echo ">> Using python env: $(which python) (pip: $(which pip))"
fi

echo ">> Executing: $CMD_STRING"

# Safely split and run the command
read -r -a CMD_ARGS <<< "$CMD_STRING"

# Historically we exec'd dotnet directly to avoid a wrapper process.
# In some environments (including CI and certain WSL setups) replacing the shell
# process with dotnet could cause unexpected segfaults. Run dotnet normally so
# the wrapper stays alive and we can capture exit codes and logs reliably.
if [[ "${CMD_ARGS[0]}" == "dotnet" ]]; then
    echo ">> Running dotnet command in a clean shell to avoid direct-invocation issues"
    bash -lc "$CMD_STRING"
else
    "${CMD_ARGS[@]}"
fi
EXIT_CODE=$?
if [[ $EXIT_CODE -ne 0 ]]; then
    echo "Command failed with exit code $EXIT_CODE"
    exit $EXIT_CODE
fi
