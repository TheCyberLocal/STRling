#!/bin/bash
set -o pipefail

# Resolve script directory to locate toolchain.json
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
TOOLCHAIN="$DIR/toolchain.json"

# Where python virtualenv will live when using python binding
VENV_DIR=".venv"

COMMAND=$1
LANG=$2

# Help / Usage
if [ -z "$COMMAND" ] || [ -z "$LANG" ]; then
    echo "Usage: ./strling <command> <language>"
    echo "Commands: setup, test, build"
    echo "Example: ./strling test python"
    exit 1
fi

if [ ! -f "$TOOLCHAIN" ]; then
    echo "Error: toolchain.json not found at $TOOLCHAIN"
    exit 1
fi

# Check for python3
if ! command -v python3 &> /dev/null; then
    echo "Error: python3 is required to parse toolchain.json"
    exit 1
fi

# Helper to get value from JSON
get_json_value() {
    local key="$1"
    python3 - <<PY
import json
try:
    data=json.load(open('$TOOLCHAIN'))
    b=data['bindings'].get('$LANG', {})
    val=b.get('$key','')
    if isinstance(val, list):
        print(' '.join(val))
    else:
        print(val)
except Exception:
    pass
PY
}

# Helper to get command string from JSON (properly quoted)
get_cmd_string() { get_json_value "$1"; }

BINDING_PATH=$(get_json_value "path")
CHECK_BIN=$(get_json_value "check_bin")

if [ -z "$BINDING_PATH" ]; then
    echo "Error: Language '$LANG' not found in toolchain.json"
    exit 1
fi

# Check if the required binary exists
# Check for required binary
if ! command -v "$CHECK_BIN" &> /dev/null; then
    echo "Error: Required tool '$CHECK_BIN' not found. Please install it to work with $LANG."
    exit 1
fi

CMD_STRING=$(get_cmd_string "$COMMAND")

if [ -z "$CMD_STRING" ]; then
    echo "No '$COMMAND' command defined for $LANG."
    exit 0
fi

echo ">> Running $COMMAND for $LANG in $BINDING_PATH..."

cd "$DIR/$BINDING_PATH" || exit 1

# Python: create & use venv so pip doesn't try to write system files
if [[ "$LANG" == "python" ]]; then
    if [[ ! -d "$VENV_DIR" ]]; then
        echo ">> Creating Python virtual environment..."
        python3 -m venv "$VENV_DIR"
    fi
    export PATH="$(pwd)/$VENV_DIR/bin:$PATH"
    echo ">> Using python env: $(which python) (pip: $(which pip))"
fi

echo ">> Executing: $CMD_STRING"

# Safely split and run the command
read -r -a CMD_ARGS <<< "$CMD_STRING"

# Historically we exec'd dotnet directly to avoid a wrapper process.
# In some environments (including CI and certain WSL setups) replacing the shell
# process with dotnet could cause unexpected segfaults. Run dotnet normally so
# the wrapper stays alive and we can capture exit codes and logs reliably.
if [[ "${CMD_ARGS[0]}" == "dotnet" ]]; then
    echo ">> Running dotnet command in a clean shell to avoid direct-invocation issues"
    bash -lc "$CMD_STRING"
else
    "${CMD_ARGS[@]}"
fi
EXIT_CODE=$?
if [[ $EXIT_CODE -ne 0 ]]; then
    echo "Command failed with exit code $EXIT_CODE"
    exit $EXIT_CODE
fi
